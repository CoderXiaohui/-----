## 03.计算机的高速缓存

### 1. 高速缓存的工作原理
#### 1.1. 字、字块
- 字：是指存放在一个存储单元中的二进制代码组合，是内存存储单元中最小的单位。（一个字可以表示一个数据、一个指令、一个字符串）
- 字块：存储在连续的存储单元中而被看作是一个单元的一组字

**字、字块、主存容量的计算：**
![](http://github-file.oss-cn-qingdao.aliyuncs.com/pasteimageintomarkdown/2020-05-28/8285638357899.png)

**字的地址：**
![](http://github-file.oss-cn-qingdao.aliyuncs.com/pasteimageintomarkdown/2020-05-28/8495092575999.png)
- 字的地址包含两个部分
- 假设前m位指定字块的地址
- 后b位指定字在字块中的地址

>假设一个字由32位、一个字块共B个字、主存中共M个字块]

2^m^ = M

2^b^ = B

```
例子：
假设主存用户空间容量为4G，字块大小为4M，字长为32位，则对于字地址中的块地址m和块内地址b的位数
至少应该是多少？
```

4G = 1024*4 = 4096M

字块数：4096/4 = 1024

字块地址m：log~2~1024 = 10

块内字数：4M / 32bit = 1048576

块内地址b：log~2~1048576 = 20

m>=10 , b>=20

#### 1.2 缓存命中率
我们知道，CPU与主存的速度不同，为了解决速度不同的问题，有了高速缓存

CPU——高速缓存——主存

如果CPU要取得数据在缓存里，那么就从缓存中去取，如果不在缓存里，就需要去主存中去拿。

- 命中率是衡量缓存的重要性能指标
- 理论上CPU每次都能从高速缓存中去取数据时，那么命中率为1

假设：

- 访问主存的次数：N~m~

- 访问缓存的次数：N~c~

**命中率：h = N~c~/(N~c~+N~m~)**

![](http://github-file.oss-cn-qingdao.aliyuncs.com/pasteimageintomarkdown/2020-05-30/6723516070800.png)


#### 1.3 缓存访问效率
假设：

- 访问效率：e
- 访问主存时间：t~m~
- 访问缓存时间：t~c~

访问Cache-主存系统平均时间：t~a~ = ht~c~ + (1-h)t~m~

e = t~c~/t~a~

e = t~c~ / (ht~c~ + (1-h)t~m~)

![](http://github-file.oss-cn-qingdao.aliyuncs.com/pasteimageintomarkdown/2020-05-30/6745496365900.png)


### 2. 高速缓存的替换策略
**高速缓存的替换时机：**
- CPU要取数据，当高速缓存中没有CPU要取得数据时，就需要从主存载入所需数据

高速缓存得替换策略：
1. 随机算法
2. 先进先出算法（FIFO）
3. 最不经常使用算法（LFU）
4. 最近最少使用算法（LRU）
#### 2.1 随机算法
    需要替换时，随机选取高速缓存的位置，然后替换掉。

#### 2.2 先进先出算法（FIFO）
- 把高速缓存当作一个先进先出的队列
- 优先替换最先进入队列的字块

#### 2.3 最不经常使用算法（LFU）
- 优先淘汰最不经常使用的字块
- 需要额外空间记录字块的使用频率

#### 2.4 最近最少使用算法（LRU）
- 优先淘汰一段时间内没有使用的字块
- 有多种实现方法，一般使用双向链表
- 把当前访问节点至于链表前面（保证链表头部节点是最近使用的）
```
假设缓存中可以存4个字块，（）表示使用的字块，[]表示淘汰的字块
（1）1
（2）2，1
（5）5，2，1
（8）8，5，2，1
（4）4，8，5，2 [1]  1被淘汰
（3）3，4，8，5 [2]  2被淘汰
（5）5，3，4，8  此处再次使用了5所以把5提前
...

```